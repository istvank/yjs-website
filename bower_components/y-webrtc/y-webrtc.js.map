{"version":3,"sources":["WebRTC.js","y-webrtc.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","WebRTC","_Y$AbstractConnector","y","options","this","undefined","Error","room","role","call","webrtcOptions","url","swr","SimpleWebRTC","self","once","userId","joinRoom","setUserId","on","peer","room_","message","type","receiveMessage","id","payload","userJoined","userLeft","disconnect","leaveRoom","reconnect","send","uid","success","webrtc","getPeers","sendDirectly","setTimeout","broadcast","sendDirectlyToAll","isDisconnected","Y","AbstractConnector"],"mappings":"AACA,YCEA,SAASA,iBAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,WAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIH,WAAU,iEAAoEG,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GAEje,GDJAW,QAAA,SAAAC,GACA,QADAD,GACAE,EAAAC,GACA,GCMIpB,gBAAgBqB,KDRpBJ,GAEAK,SAAAF,EACA,KAAA,IAAAG,OAAA,iCAEA,IAAA,MAAAH,EAAAI,KACA,KAAA,IAAAD,OAAA,+BAEAH,GAAAK,KAAA,QACAP,EAAAQ,KAAAL,KAAAF,EAAAC,GACAC,KAAAM,eACAC,IAAAR,EAAAQ,KAAA,2BACAJ,KAAAJ,EAAAI,KAEA,IAAAK,GAAA,GAAAC,cAAAT,KAAAM,cACAN,MAAAQ,IAAAA,CACA,IAAAE,GAAAV,IACAQ,GAAAG,KAAA,kBAAA,SAAAC,GAEAJ,EAAAK,SAAAH,EAAAJ,cAAAH,MAEAK,EAAAG,KAAA,aAAA,WACAD,EAAAI,UAAAF,GAQAJ,EAAAO,GAAA,iBAAA,SAAAC,EAAAC,EAAAC,GAIA,MAAAA,EAAAC,MACAT,EAAAU,eAAAJ,EAAAK,GAAAH,EAAAI,aAKAd,EAAAO,GAAA,cAAA,SAAAC,GAIAN,EAAAa,WAAAP,EAAAK,GAAA,YAGAb,EAAAO,GAAA,oBAAA,SAAAC,GAIAN,EAAAc,SAAAR,EAAAK,QCmDE,MAjGAtC,WDLFa,EAAAC,GAAAD,EAAAV,UAuDAuC,WAAA,WACAzB,KAAAQ,IAAAkB,YACA7B,EAAAX,UAAAuC,WAAApB,KAAAL,OAzDAJ,EAAAV,UA2DAyC,UAAA,WACA3B,KAAAQ,IAAAK,SAAAb,KAAAM,cAAAH,MACAN,EAAAX,UAAAyC,UAAAtB,KAAAL,OA7DAJ,EAAAV,UA+DA0C,KAAA,QAAAA,GAAAC,EAAAX,GACA,GAAAR,GAAAV,KAEA4B,EAAA,QAAAA,KAEA,GACAE,GADAd,EAAAN,EAAAF,IAAAuB,OAAAC,SAAAH,GAAA,EAEAb,KAEAc,EAAAd,EAAAiB,aAAA,eAAA,MAAAf,IAEAY,GAEAI,WAAAN,EAAA,KAIAA,MAhFAhC,EAAAV,UAkFAiD,UAAA,SAAAjB,GACAlB,KAAAQ,IAAA4B,kBAAA,eAAA,MAAAlB,IAnFAtB,EAAAV,UAqFAmD,eAAA,WACA,OAAA,GAtFAzC,GAAA0C,EAAAC,kBA0FAD,GAAA1C,OAAAA","file":"y-webrtc.js","sourcesContent":["/* global Y, SimpleWebRTC */\n'use strict'\n\nclass WebRTC extends Y.AbstractConnector {\n  constructor (y, options) {\n    if (options === undefined) {\n      throw new Error('Options must not be undefined!')\n    }\n    if (options.room == null) {\n      throw new Error('You must define a room name!')\n    }\n    options.role = 'slave'\n    super(y, options)\n    this.webrtcOptions = {\n      url: options.url || 'https://yatta.ninja:8888',\n      room: options.room\n    }\n    var swr = new SimpleWebRTC(this.webrtcOptions)\n    this.swr = swr\n    var self = this\n    swr.once('connectionReady', function (userId) {\n      // SimpleWebRTC (swr) is initialized\n      swr.joinRoom(self.webrtcOptions.room)\n\n      swr.once('joinedRoom', function () {\n        self.setUserId(userId)\n        /*\n        var i\n        // notify the connector class about all the users that already\n        // joined the session\n        for(i in self.swr.webrtc.peers){\n          self.userJoined(self.swr.webrtc.peers[i].id, \"master\")\n        }*/\n        swr.on('channelMessage', function (peer, room_, message) {\n          // The client received a message\n          // Check if the connector is already initialized,\n          // only then forward the message to the connector class\n          if (message.type != null) {\n            self.receiveMessage(peer.id, message.payload)\n          }\n        })\n      })\n\n      swr.on('createdPeer', function (peer) {\n        // a new peer/client joined the session.\n        // Notify the connector class, if the connector\n        // is already initialized\n        self.userJoined(peer.id, 'master')\n      })\n\n      swr.on('peerStreamRemoved', function (peer) {\n        // a client left the session.\n        // Notify the connector class, if the connector\n        // is already initialized\n        self.userLeft(peer.id)\n      })\n    })\n  }\n  disconnect () {\n    this.swr.leaveRoom()\n    super.disconnect()\n  }\n  reconnect () {\n    this.swr.joinRoom(this.webrtcOptions.room)\n    super.reconnect()\n  }\n  send (uid, message) {\n    var self = this\n    // we have to make sure that the message is sent under all circumstances\n    var send = function () {\n      // check if the clients still exists\n      var peer = self.swr.webrtc.getPeers(uid)[0]\n      var success\n      if (peer) {\n        // success is true, if the message is successfully sent\n        success = peer.sendDirectly('simplewebrtc', 'yjs', message)\n      }\n      if (!success) {\n        // resend the message if it didn't work\n        setTimeout(send, 500)\n      }\n    }\n    // try to send the message\n    send()\n  }\n  broadcast (message) {\n    this.swr.sendDirectlyToAll('simplewebrtc', 'yjs', message)\n  }\n  isDisconnected () {\n    return false\n  }\n}\n\nY.WebRTC = WebRTC\n",null],"sourceRoot":"/source/"}